#' This is an R function to perform stepwise regression based on a "nested model" F test for inclusion/exclusion
#' of a predictor.  To keep it simple, I made no provision for forcing certain variables to be included in
#' all models, did not allow for specification of a data frame, and skipped some consistency checks (such as whether
#' the initial model is a subset of the full model).
#'
#' One other note: since the code uses R's drop1 and add1 functions, it respects hierarchy in models. That is,
#' regardless of p values, it will not attempt to drop a term while retaining a higher order interaction
#' involving that term, nor will it add an interaction term if the lower order components are not all present.
#' (You can of course defeat this by putting interactions into new variables and feeding it what looks like
#' a first-order model.)
#'
#' Consider this to be "beta" code (and feel free to improve it).  I've done very limited testing on it.
#'
#' Author: Paul A. Rubin (rubin@msu.edu)
#' @param full.model A model formula
#' @param initial.model A model formula
#' @param XX  a data.frame
#' @keywords  stepwise linear regression Bonferroni
#' @export
#' full.model <- mpg~ .
#' initial.model <- mpg~ 1
#' aa<-forward.stepwise.FDR(full.model, initial.model,XX=mtcars)





forward.stepwise.FDR <- function(full.model, initial.model, XX) {
    ## full.model is the model containing all possible terms
    ## initial.model is the first model to consider
    ## (Useful things for someone to add: specification of a data frame; a list of variables that must be included)


    env<-environment()
    environment(full.model) <- env
    environment(initial.model) <-env

    all.variables<-dim(XX)[2]-1
    
    full <- lm(full.model,data=XX);  ## fit the full model
    msef <- (summary(full)$sigma)^2;  ## MSE of full model
    n <- length(full$residuals);  ## sample size
    allvars <- attr(full$terms, "predvars");  ## this gets a list of all predictor variables
    current <- lm(initial.model,data=XX);  ## this is the current model
    
    while (TRUE) {  ## process each model until we break out of the loop
        temp <- summary(current);  ## summary output for the current model
        rnames <- rownames(temp$coefficients);  ## list of terms in the current model
        ##        print(temp$coefficients);  ## write the model description
        p <- dim(temp$coefficients)[1];  ## current model's size
        mse <- (temp$sigma)^2;  ## MSE for current model
        cp <- (n-p)*mse/msef - (n-2*p);  ## Mallow's cp
        fit <- sprintf("\nS = %f, R-sq = %f, R-sq(adj) = %f, C-p = %f",
                       temp$sigma, temp$r.squared, temp$adj.r.squared, cp);
        ##        write(fit, file="");  ## show the fit
        ##        write("=====", file="");  ## print a separator
        a <- tryCatch(add1(current, scope=full, test="F"), error=function(e) NULL);  ## looks for significance of possible additions based on F tests
        if (is.null(a)) {
            break;  ## there are no unused variables (or something went splat), so we bail out
        }
        print(a)
        tmax <- max(a[-1,5]); 
        pmin <- min(a[-1,6]);  ## minimum p-value of any term (skipping the intercept again)
        
        if (is.nan(tmax)| is.na(tmax) |is.nan(pmin) | is.na(pmin) ) {
            return(current);  #### something wrong
        }
        
        if (pmin < 0.25*(p+1)/all.variables) {
            ## we have a candidate for addition to the model
            var <- rownames(a)[a[,5] == tmax];  ## name of variable to add
            if (length(var) > 1) {
                ## same issue with ties, intercept as above
                var <- var[2];
            }
            ##      write(paste("+++ Adding", var, "\n"), file="");  ## print the variable being added
            f <- formula(current);  ## current formula
            f <- as.formula(paste(f[2], "~", paste(f[3], var, sep=" + ")));  ## modify the formula to add the chosen variable
            current <- lm(f,data=XX);  ## fit the modified model
            next;  ## return to the top of the loop
        }
        ## if we get here, we failed to make any changes to the model; time to punt
        break;
    }
    return(current)
}
